---
title: 'Writing Effective CLAUDE.md Files: Real Examples, Patterns, and What Not to Include'
date: '2026-02-18'
tags: ['claude', 'developer-tools', 'automation', 'dx', 'ai']
draft: false
summary: Your CLAUDE.md is a contract between you and an AI developer. Most are too long, full of style rules a linter should enforce, and missing the context Claude actually needs. Here's what the best ones look like — with real examples from production monorepos, single-package libraries, and Anthropic's own teams.
---

**TL;DR:** A good CLAUDE.md is short (~100-200 lines), opinionated, and focused on things Claude can't figure out by reading your code. It documents build commands, architectural decisions, common mistakes, and verification steps. It does _not_ duplicate your linter config, embed code snippets that go stale, or try to be a comprehensive project manual. The best teams treat it like a living runbook — updated multiple times a week based on what Claude actually gets wrong.

---

In the [companion post on hardening your Claude Code setup](/blog/hardening-claude-code-hooks-permissions-verification), I covered hooks, permissions, and verification checkpoints — the automation layers that catch mistakes mechanically. But all of that machinery runs on top of one foundational file: `CLAUDE.md`.

Most developers either skip it entirely or dump everything they know about their project into it. Both approaches fail. This post shows what works, drawing from real production examples and the practices of the team that built Claude Code itself.

## What CLAUDE.md Actually Is

CLAUDE.md is a markdown file that Claude Code reads at the start of every session. It becomes part of Claude's system prompt — the persistent context that shapes every response and action.

Think of it as onboarding documentation for a new developer who is extremely capable but has zero institutional knowledge. You wouldn't hand a new hire your entire wiki. You'd give them the 20% of context that covers 80% of their first week.

### The File Hierarchy

Claude Code loads CLAUDE.md files from multiple locations in a specific order of precedence:

| Location                         | Scope                 | Checked into git? |
| -------------------------------- | --------------------- | ----------------- |
| `~/.claude/CLAUDE.md`            | All projects (global) | No                |
| `CLAUDE.md` (project root)       | Whole team, this repo | Yes               |
| `CLAUDE.local.md` (project root) | Just you, this repo   | No (gitignored)   |
| `packages/api/CLAUDE.md`         | Subdirectory-scoped   | Yes               |

**How loading works:** Ancestor files (above your working directory) load eagerly at startup. Descendant files (in subdirectories below) load lazily — only when Claude reads files in that directory. This means in a monorepo, the frontend team's instructions don't consume tokens until Claude actually touches frontend code.

More specific files take precedence over broader ones. If your root CLAUDE.md says "use npm" but `packages/api/CLAUDE.md` says "use pnpm," the pnpm instruction wins when Claude is working in that directory.

You can also import other files with `@path/to/file` syntax. Relative paths resolve relative to the file containing the import, not your working directory. Imports can be nested up to 5 levels deep. Use this for small, stable files — not for pulling in your entire docs folder.

On enterprise setups, there's also a **managed policy** location (`/etc/claude-code/CLAUDE.md` on Linux, `/Library/Application Support/ClaudeCode/CLAUDE.md` on macOS) for organization-wide rules set by IT/DevOps. These have the lowest precedence — project files always override them.

## The Target: ~100 Lines, ~2.5k Tokens

Boris Cherny, head of Claude Code at Anthropic, keeps his team's CLAUDE.md at roughly 2.5k tokens (~100 lines). Most developers are at 10,000+ tokens and getting _worse_ results.

Why? As instruction count increases, instruction-following quality degrades _uniformly_ — Claude doesn't just ignore newer instructions, it starts ignoring all of them. Research suggests frontier LLMs can reliably follow ~150-200 instructions. Claude Code's system prompt already contains ~50, which means your CLAUDE.md has a budget of roughly 100-150 instructions before quality drops off a cliff.

Every line should earn its place. For each instruction, ask: "Would removing this cause Claude to make a mistake?" If the answer is no, cut it.

## Anatomy of a Good CLAUDE.md

The best files share a consistent structure. Here's what each section should cover:

### 1. Project Overview (2-3 lines)

Not a README. Just enough context that Claude knows what kind of codebase it's in.

```markdown
## Project

TypeScript monorepo for a SaaS API platform. Turborepo + pnpm workspaces.
Packages: web (Next.js 15), api (Hono), shared (core types + utilities).
```

### 2. Essential Commands

The commands Claude needs to build, test, lint, and verify. This is the highest-value section — Claude can't infer these from code alone, and getting them wrong wastes entire sessions.

```markdown
## Commands

- Build: `pnpm build` (all packages) or `pnpm --filter api build`
- Test: `pnpm test` (unit) or `pnpm --filter api test:integration` (requires Docker)
- Lint: `pnpm lint`
- Type check: `pnpm typecheck`
- Format: `pnpm format`
- Codegen: `pnpm generate` (run after changing any .graphql file)
```

Be specific. "Run the tests" is useless. `pnpm --filter api test:integration` is actionable.

### 3. Architecture Decisions Claude Can't Infer

Document the _why_, not the _what_. Claude can read your code to see what you did. It can't read your mind to know why.

```markdown
## Architecture

- Database access goes through repository classes only — never raw SQL in handlers
- Feature flags via LaunchDarkly SDK — check before using environment variables
- All API responses use the Result<T, E> wrapper from @acme/core/types
- Internal package dependencies use workspace:\* protocol
```

### 4. Common Mistakes (the Feedback Flywheel)

This is the section Anthropic's own teams update multiple times a week. When Claude makes a mistake, add it here so it doesn't repeat.

```markdown
## Common Mistakes

- Do NOT import from @acme/core/src — use @acme/core (the package export)
- Generated types live in src/generated/ — never edit these manually, run `pnpm generate`
- The auth middleware must be applied before rate limiting (order matters in the stack)
- Use `vi.mock()` not `jest.mock()` — this project uses Vitest, not Jest
```

### 5. Verification Checkpoints

Tell Claude _when_ to verify, not just _how_. This section is the bridge between CLAUDE.md and the [verification checkpoints covered in the hardening post](/blog/hardening-claude-code-hooks-permissions-verification).

```markdown
## Verification

After completing any unit of work:

1. `pnpm --filter <affected-package> typecheck`
2. `pnpm --filter <affected-package> test`

Before claiming a task is complete:

1. `pnpm lint && pnpm typecheck`
2. All tests pass
```

## Real-World Examples

Let's look at how production projects actually structure their CLAUDE.md files — from five-line pointers to comprehensive monorepo guides.

### facebook/react: The Minimal Pointer

[React's CLAUDE.md](https://github.com/facebook/react/blob/main/CLAUDE.md) is roughly five lines:

```markdown
# React

React is a JavaScript library for building user interfaces.

## Monorepo Overview

- **React**: All files outside `/compiler/`
- **React Compiler**: `/compiler/` directory (has its own instructions)
```

That's it. The root file is a router — it tells Claude that React and React Compiler are separate workspaces, each with their own CLAUDE.md. This leverages lazy-loading: the compiler's instructions only load when Claude touches `/compiler/` files.

**Takeaway:** In a monorepo, the root file's job is to _orient_, not to _instruct_. Push the details into subdirectory files.

### anthropics/claude-code-action: "Things That Will Bite You"

[Anthropic's own GitHub Action](https://github.com/anthropics/claude-code-action/blob/main/CLAUDE.md) for Claude Code demonstrates one of the most effective section patterns — a "Things That Will Bite You" section that names the gotchas directly:

```markdown
## Things That Will Bite You

- Strict TypeScript: noUnusedLocals and noUnusedParameters are enabled.
- Discriminated unions for GitHub context — call isEntityContext(context) first.
- Token lifecycle matters: revocation is in a separate always() step.
- Error phase attribution uses prepareCompleted flag.
- action.yml outputs reference step IDs — rename carefully.
- Integration testing happens in a separate repo.
```

This naming is intentional. "Common Mistakes" is passive — "Things That Will Bite You" grabs attention. Every line is a specific, non-obvious trap that Claude would fall into without warning.

They also include a crisp two-paragraph "How It Runs" section that maps the entire execution flow, and a "Key Concepts" section with the three most important architectural decisions. Total file: ~60 lines.

### metabase/metabase: The Skills-Only Approach

[Metabase](https://github.com/metabase/metabase/blob/master/CLAUDE.md) takes an extreme approach — their root CLAUDE.md is almost entirely pointers:

```markdown
# Skills

For detailed guidance on writing and reviewing code and documentation,
see the skills in .claude/skills/:

## Clojure

- clojure-write - Clojure/ClojureScript development with REPL-driven workflow
- clojure-review - Clojure/ClojureScript code review guidelines

## TypeScript

- typescript-write - TypeScript/JavaScript development and best practices
- typescript-review - TypeScript/JavaScript code review guidelines

## Documentation

- docs-write - Documentation writing with Metabase style guide
- docs-review - Documentation review checklist

**Important**: When working with frontend code, read frontend/CLAUDE.md
for project-specific guidelines.
```

Zero commands. Zero architecture docs. Just a map to skills and subdirectory files. This works because Metabase is a large multi-language codebase (Clojure + TypeScript) — loading Clojure patterns when you're editing React components would waste tokens. Skills load on demand, and subdirectory CLAUDE.md files load lazily.

**Takeaway:** For large, multi-language codebases, consider moving most content into skills and subdirectory files. The root file becomes a table of contents.

### modelcontextprotocol/python-sdk: FORBIDDEN Markers

The [MCP Python SDK](https://github.com/modelcontextprotocol/python-sdk/blob/main/CLAUDE.md) uses strong emphasis markers to flag absolute rules:

```markdown
## Core Development Rules

1. Package Management
   - ONLY use uv, NEVER pip
   - FORBIDDEN: uv pip install, @latest syntax

2. Code Quality
   - Type hints required for all code
   - FORBIDDEN: imports inside functions. THEY SHOULD BE AT THE TOP OF THE FILE.

3. Testing Requirements
   - Framework: uv run --frozen pytest
   - IMPORTANT: tests/client/test_client.py is the most well designed test file.
     Follow its patterns.
   - IMPORTANT: Be minimal, focus on E2E tests using mcp.client.Client whenever possible.
```

Note the graduated emphasis: plain text for standard rules, IMPORTANT for strong preferences, FORBIDDEN for absolute prohibitions. This hierarchy helps Claude calibrate how strictly to follow each rule. But use it sparingly — if everything is IMPORTANT, nothing is.

### Supabase JS SDK: Package-Specific Commands

The [supabase-js](https://github.com/supabase/supabase-js) repository is an Nx monorepo containing six packages. Their CLAUDE.md demonstrates how to document environment-dependent commands:

```markdown
| Package      | Docker | Complete Test Command               |
| ------------ | ------ | ----------------------------------- |
| auth-js      | ✅     | `nx test:auth auth-js`              |
| storage-js   | ✅     | `nx test:storage storage-js`        |
| postgrest-js | ✅     | `nx test:ci:postgrest postgrest-js` |
| functions-js | ✅     | `nx test functions-js`              |
| realtime-js  | ❌     | `nx test realtime-js`               |
| supabase-js  | ❌     | `nx test supabase-js`               |
```

They also list exact valid commit scopes (`auth, functions, postgrest, realtime, storage, supabase, repo, deps, ci, release, docs, scripts, misc`) and a concrete anti-patterns section. The pattern of specifying which tests need Docker and which don't saves Claude from trial-and-error that would burn through context.

### Small Single-Package Project

For smaller projects, you need far less. Here's a pattern distilled from several effective single-package CLAUDE.md files:

```markdown
## Project

Astro 5 blog with Tailwind CSS 4 and TypeScript.

## Commands

- Dev: `pnpm dev`
- Build: `pnpm build`
- Format: `pnpm run format`
- Lint: `pnpm run lint`
- Type check: `pnpm run type-check`

## Conventions

- Prefer types over interfaces for TypeScript
- Favor smaller, modular components over monolithic ones
- Review existing patterns in the codebase before creating new abstractions

## After Completing Any Task

Run in this order:

1. `pnpm run format`
2. `pnpm run lint`
3. `pnpm run type-check`
```

That's ~25 lines. Enough for Claude to be productive without any hand-holding.

## Monorepo vs. Single Package: How to Scope

The key difference is _where_ instructions live, not _how many_ you write.

### Single Package

One `CLAUDE.md` at the root. Everything in one file. Keep it under 100 lines.

```
my-app/
├── CLAUDE.md          # Everything goes here
├── CLAUDE.local.md    # Your personal preferences (gitignored)
├── src/
└── package.json
```

### Monorepo

Layer your instructions. Root file for shared conventions, package files for specifics.

```
platform/
├── CLAUDE.md               # Shared: commit style, CI commands, architecture overview
├── packages/
│   ├── web/
│   │   └── CLAUDE.md       # Next.js patterns, component conventions
│   ├── api/
│   │   └── CLAUDE.md       # API patterns, middleware stack, DB access rules
│   └── shared/
│       └── CLAUDE.md       # Export conventions, type generation
└── services/
    └── billing/
        └── CLAUDE.md       # Billing-specific domain rules, Stripe integration notes
```

**Root CLAUDE.md** (shared across all packages):

```markdown
## Platform

TypeScript monorepo. Turborepo + pnpm workspaces.

## Commit Convention

Conventional commits required. Format: `type(scope): description`
Valid scopes: web, api, shared, billing, infra, ci, docs

## Commands (full repo)

- Build all: `turbo run build`
- Lint all: `turbo run lint`
- Type check all: `turbo run typecheck`

## Architecture

- Package dependencies flow downward only: web → api → shared
- Shared types live in @platform/shared/types
- Database access exclusively through repository pattern in @platform/api
```

**packages/api/CLAUDE.md** (API-specific):

```markdown
## API Package

Hono HTTP framework with tRPC for internal RPC.

## Commands

- Dev: `pnpm --filter api dev`
- Test: `pnpm --filter api test`
- Test (integration, needs Docker): `pnpm --filter api test:integration`

## Patterns

- All routes defined in src/routes/ — one file per resource
- Middleware stack order: auth → rate-limit → validation → handler
- Use Result<T, E> for all handler returns — never throw from handlers
- Database queries go through src/repositories/ — never raw SQL in routes
```

The root is ~20 lines. Each package file is ~15 lines. Claude only loads what's relevant to the code it's touching.

### The Rules Directory: Modular Alternative

If your CLAUDE.md is getting long, Claude Code offers `.claude/rules/` — a directory where you can split instructions into focused, per-topic files:

```
my-project/
├── CLAUDE.md                    # Core project context (kept short)
├── .claude/
│   └── rules/
│       ├── code-style.md        # Loaded at startup (unconditional)
│       ├── testing.md           # Loaded at startup (unconditional)
│       ├── frontend.md          # Loaded only for matching paths ↓
│       └── api.md               # Loaded only for matching paths ↓
```

The key feature: **path-specific conditional rules**. Add a `paths` frontmatter block, and the rule only loads when Claude touches matching files:

```markdown
---
paths:
  - 'src/api/**/*.ts'
---

# API Development Rules

- All endpoints must include input validation using zod schemas
- Use the standard error response format from src/lib/errors.ts
- Integration tests required for any new endpoint
```

Rules without `paths` frontmatter load unconditionally at startup, just like CLAUDE.md. This gives you the best of both worlds: shared rules stay short, and domain-specific rules only consume context when relevant.

In a large monorepo, this can be more ergonomic than scattering CLAUDE.md files across dozens of subdirectories. You get the same lazy-loading benefit with a single centralized directory.

## What NOT to Put in CLAUDE.md

This is where most people go wrong. Here are the most common mistakes, ranked by how much damage they do.

### 1. Code Style Rules → Use a Linter

**The single most common mistake.** Never send an LLM to do a linter's job. Linters are fast, deterministic, and free. LLMs are slow, probabilistic, and expensive.

```markdown
# ❌ Don't put this in CLAUDE.md

- Use 2-space indentation
- Always use semicolons
- Prefer single quotes over double quotes
- Maximum line length of 100 characters
- Use trailing commas in multi-line arrays

# ✅ Instead, use a PostToolUse hook that runs your formatter

# Claude gets instant feedback on every edit — no instructions needed
```

If your linter catches it, your CLAUDE.md doesn't need to mention it.

### 2. Embedded Code Snippets → Use File Pointers

Code in CLAUDE.md goes stale the moment someone changes the source. Point to the real file instead.

```
# ❌ Don't embed code examples
Here's how to create a new API route:
[30 lines of Hono boilerplate...]

# ✅ Point to a real file
For new API routes, follow the pattern in src/routes/users.ts
```

### 3. Everything the Model Already Knows

Claude knows how TypeScript works. It knows how React hooks work. It knows what `async/await` does. Don't waste tokens restating common knowledge.

```markdown
# ❌ Don't

- Use async/await instead of raw promises
- React components should be functional, not class-based
- Use TypeScript generics for type-safe collections

# ✅ Do (only document what's specific to YOUR project)

- Use the AsyncResult<T> wrapper from @acme/core — not raw promises
```

### 4. Prohibitions Without Alternatives

Telling Claude "never do X" leaves it stuck. Always provide the alternative.

```markdown
# ❌ Don't

- Never use the --force flag

# ✅ Do

- Never use git push --force; use git push --force-with-lease instead
```

### 5. The Entire Project Manual

If you find yourself writing more than 200 lines, you're writing documentation, not instructions. Move the details into separate docs and point to them.

```markdown
# ❌ Don't: 500-line CLAUDE.md with every API endpoint documented

# ✅ Do: 5-line pointer

## API Documentation

- Endpoint reference: see docs/api-reference.md
- Auth flow: see docs/authentication.md
- Error codes: see docs/error-handling.md
```

### 6. @-file Imports of Large Documents

The `@path/to/file` syntax embeds the entire file into Claude's context _on every session_. Use it sparingly for small, stable files. For large or frequently-changing docs, use a path reference instead and let Claude read it on demand.

## The Feedback Flywheel

The best CLAUDE.md files aren't written once — they're maintained through a continuous loop:

1. **Claude makes a mistake** (uses wrong test command, imports from wrong path, forgets to run codegen)
2. **You add it to the Common Mistakes section** ("use `nx test:auth auth-js`, not `nx test auth-js`")
3. **Claude stops making that mistake**
4. **Repeat**

At Anthropic, teams update their CLAUDE.md multiple times a week. In code review, engineers tag `@.claude` on pull requests to add learnings — using the Claude Code GitHub action. The review process isn't just about catching bugs in the current PR; it's about training the development system for the next one.

This creates a virtuous cycle: every mistake makes the system better. Over weeks, your CLAUDE.md converges on exactly the institutional knowledge Claude needs.

There's a shortcut for this: after Claude makes a correction, tell it "Update the CLAUDE.md so you don't make that mistake again." Cherny has noted that Claude is surprisingly good at writing rules for itself — the resulting instructions are often more precise than what you'd write manually, because Claude knows exactly what confused it.

### The Canary Phrase Trick

How do you know when your CLAUDE.md is too long? Some developers use a **canary phrase** — a line buried in the middle of their instructions like:

```markdown
Always refer to me as "Shaun" in all communications.
```

or a fake address Claude should use. If Claude stops using the canary phrase, your file is too long and instructions are being dropped. It's a crude but effective smoke test for context window overload.

## Skills for Domain Knowledge

One more lever: if you have domain-specific workflows that only matter sometimes (deploying to staging, running database migrations, debugging a particular subsystem), don't put them in CLAUDE.md. Use `.claude/skills/` instead.

Skills are markdown files that Claude loads _on demand_ — invoked through slash commands or automatically when relevant. They don't consume context in every session, only when needed.

```
.claude/
├── skills/
│   ├── deploy-staging.md      # /deploy-staging
│   ├── db-migration.md        # /db-migration
│   └── debug-auth.md          # /debug-auth
```

Rule of thumb: if it applies to &gt;80% of sessions, put it in CLAUDE.md. If it applies to &lt;20%, make it a skill. If it's somewhere in between, use a conditional rule with `paths` frontmatter in `.claude/rules/`.

## CLAUDE.md vs. CLAUDE.local.md

Use `CLAUDE.md` (checked into git) for team-wide instructions:

- Build and test commands
- Architecture decisions
- Commit conventions
- Common mistakes

Use `CLAUDE.local.md` (gitignored) for personal preferences:

- Your preferred editor settings
- Custom shortcuts or aliases
- Personal verification workflows
- Experimental instructions you're testing before promoting to the team file

This separation means the team file stays clean and authoritative, while individuals can experiment without affecting others.

## A Starter Template

Here's a template you can adapt. Delete sections that don't apply. Add specifics for your project.

```markdown
## Project

[1-2 sentences: what this project is, core tech stack]

## Commands

- Build: `[command]`
- Test: `[command]`
- Test (single file): `[command] path/to/test`
- Lint: `[command]`
- Type check: `[command]`
- Format: `[command]`

## Architecture

- [Key architectural decision Claude can't infer from code]
- [Another one]
- [Where new code should go for common tasks]

## Conventions

- [Naming conventions specific to this project]
- [Import/export patterns]
- [Error handling patterns]

## Common Mistakes

- [Thing Claude gets wrong] → [what to do instead]
- [Another thing] → [the fix]

## Verification

After completing any unit of work:

1. [Scoped type check command]
2. [Scoped test command]

Before claiming complete:

1. [Full lint + type check]
2. All tests pass
```

## A Note on AGENTS.md

You may see some repositories (like Next.js) using `AGENTS.md` instead of `CLAUDE.md`. This is a cross-tool format — Codex, Amp, Cursor, and other AI coding tools read `AGENTS.md` as their equivalent of `CLAUDE.md`. If your team uses multiple AI coding tools, maintaining both files (or symlinking one to the other) keeps everyone's agent productive. Claude Code reads `CLAUDE.md`; it does not currently read `AGENTS.md`.

## Putting It All Together

Your CLAUDE.md is one layer in a three-layer system:

| Layer           | What it does                                          | Enforcement                       |
| --------------- | ----------------------------------------------------- | --------------------------------- |
| **CLAUDE.md**   | Provides context, conventions, and verification steps | Advisory — Claude _should_ follow |
| **Hooks**       | Auto-format, lint, codegen reminders on every edit    | Deterministic — runs every time   |
| **Permissions** | Block destructive commands                            | Hard limit — can't be overridden  |

CLAUDE.md handles the things that require judgment — when to run which test suite, what architectural patterns to follow, which mistakes to avoid. Hooks handle the things that should happen mechanically on every edit. Permissions handle the things that should never happen at all.

The instructions tell Claude what good looks like. The hooks ensure it meets the bar. The permissions ensure it can't do damage trying. Together, they turn a capable-but-amnesiac AI into a reliable development partner that carries your team's institutional knowledge into every session.

Start with 30 lines. Add a mistake every time Claude gets something wrong. Delete anything that a linter, formatter, or hook could handle instead. In two weeks, you'll have a CLAUDE.md that's short, specific, and worth more than a 500-line manual — because every line in it was earned by a real mistake.
